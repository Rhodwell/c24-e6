# Rust: Ownership & Borrowing
## Introduction
Rust is a low-level programming language designed for performance, safety, and concurrency. It aims to address common issues from other programming languages such as C and C++. Unlike other languages we have seen throughout the course, Rust does not have a garbage collector like Python or Haskell nor manual memory management like C. Rust introduces _ownership_ and _borrowing_ as compile-time memory management systems. These concepts are important to how Rust ensures memory safety without needing a garbage collector. 

In this lesson, we'll cover core concepts of ownership rules, and borrowing in Rust, using multiple illustrative examples. 

ADD SOME MORE HERE

## Variable Scope & Lifetime
Before we go into ownership, it is important to give a quick overview of Rust's memory management. In Rust, the scope of a variable determines when it is valid and when it is dropped. The lifetime of a variable begins when it's declared and ends when it goes out of scope.

```rust
fn main() {
    {                      // begin scope
        let x = 5;         // x is valid from this point forward
        println!("{}", x); // x is used here
    }                      // end scope, x is no longer valid and is dropped
}
```

When a variable goes out of scope in Rust, a special function called `drop` is automatically called at run time to free the value associated with that variable. It is similar to the `free` function in C, but with a key difference—Rust handles it for you. This automatic cleanup helps prevent common mistakes, like forgetting to free heap-allocated memory. The information provided so far suggests that it is still possible to produce memory problems such as double-free. As the term implies, double-free happens when a programmer attempts to free memory that has already been deallocated. In Rust, we can prevent these problems before our code even runs by utilizing the principle of ownership, which we will discuss next.

## Ownership
Ownership refers to the set of rules that govern how memory is managed in Rust. The rules are as follow:
-   Each value in Rust has an _owner_.
-   There can only be one owner at a time.
-   When the owner goes out of scope, the value will be dropped.

These rules are enforced by the compiler, making sure our code is safe before we can run it. Intuitively, if each value always have a single owner throughout its lifetime, and only that owner is allowed to drop the value, then memory will never be freed more than once or accessed after being freed.

### Ownership in Action
To demonstrate these rules, consider the following:

```rust
fn main() {
    let first = String::from("CSCC24");
    let second = first;
}
```

When the program executes the second line, memory is allocated on the heap to hold the string `"CSCC24"`. The variable `first` is pushed on the stack, containing a pointer to the memory allocated on the heap, as well as the length and capacity of the allocated memory. At this stage, `first` is the owner of the string value. When the program reaches the third line, the variable `second` is added to the stack, containing a pointer to the same heap location as `first`. To ensure that the string with `CSCC24` has a single owner, Rust _moves_ the ownership to `second`, making `first` invalid and preventing use-after-free and double-free. Consequently, attempting to use `first` afterwards would lead to a compilation error.

```rust
fn main() {
    let s1 = String::from("CSCC24");
    let s2 = s1;
    println!("The value of s1 is: {s1}");
}
```

```rust
Output:
  ...
 --> src/main.rs:8:35
  |
6 |     let s1 = String::from("CSCC24");
  |         -- move occurs because `s1` has type `String`, which does not implement the `Copy` trait
7 |     let s2 = s1;
  |              -- value moved here
8 |     println!("The value of s1 is: {s1}");
  |                                   ^^^^ value borrowed here after move
  ...
```
**_Note_:** The output refers to the `Copy` trait, which can be compared to a function in an object in Java. If a function is defined for an object, the program will try to use that specific implementation. If it is not defined, a default implementation will be used instead. In the same way, if a type in Rust does not have the `Copy` trait defined, it will default to moving ownership. For primitive data types such as integers, floats, booleans, and characters, the Copy trait is implemented, specifically cloning/copying as these types have known sizes during compile-time.

### Ownership in Functions
#### How does this behavior apply to functions and argument passing?
It works exactly as expected.

```rust
fn print_string(func_s: String) {
    println!("{}", func_s);
}

fn main() {
    let main_s = String::from("CSCC24");
    print_string(main_s);
    // println!("The string is: {}", s); // This line will cause a compile-time error
}
```

Explanation:

1. Memory is allocated on the heap for the string `"CSCC24"`, and `main_s` is created on the stack as a pointer to that memory.
2. When `main_s` is passed to the `print_string` function, ownership of the `String` is **moved** to the parameter `func_s`.
3. Inside `print_string`, the content of the string is printed to the standard output.
4. After `func_s` goes out of scope (when the function ends), the heap memory holding `"CSCC24"` is automatically deallocated since `func_s` was its final owner.
5. If we uncomment the final `println!` line in `main`, we get a **compile-time error** because `main_s` no longer holds valid ownership of the string.

#### What if we want to use the variable after calling the function?

If we want to use `main_s` right after calling `print_string`, we can return the string. It would look something similar to:

```rust
fn print_string(func_s: String) {
    println!("{}", func_s);
    func_s
}

fn main() {
    let mut main_s = String::from("CSCC24");
    main_s = print_string(main_s);
    println!("The string is: {}", s);
}
```

Explanation:

1. `main_s` is initialized with the string `"CSCC24"` and owns the heap memory.
2. When `main_s` is passed into `print_string`, its ownership is _moved_ to `func_s`.
3. Inside `print_string`, we print the string. Before the function ends, we **return** `func_s`, which transfers the ownership **back to the caller**.
4. In `main`, we assign the return value of `print_string(main_s)` back into `main_s`, which means `main_s` **regains ownership** of the string.
5. Now that `main_s` is valid again, we can safely use it in the second `println!`.

As our programs becomes more complex, constantly returning variables just to keep using them can become repetitive and inconvenient. This is where one of Rust's core features, **borrowing**, comes into play to make things simpler and more flexible.

## Borrowing
Borrowing 


The restriction preventing multiple mutable references to the same data at the same time allows for mutation but in a very controlled fashion.

The benefit of having this restriction is that Rust can prevent data races at compile time. A data race is similar to a race condition and happens when these three behaviors occur:
    Two or more pointers access the same data at the same time.
    At least one of the pointers is being used to write to the data.
    There’s no mechanism being used to synchronize access to the data.

We also cannot have a mutable reference while we have an immutable one to the same value.



## References
https://doc.rust-lang.org/book/title-page.html
https://doc.rust-lang.org/nomicon/intro.html
Programming Rust O Reiley
Rust for Rustaceans
https://doc.rust-lang.org/rust-by-example/index.html
